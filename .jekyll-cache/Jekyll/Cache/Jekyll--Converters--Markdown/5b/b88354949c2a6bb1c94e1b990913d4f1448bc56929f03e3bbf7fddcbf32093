I"<h1 id="829">8/29</h1>

<h3 id="单例模式">–单例模式</h3>

<ul>
  <li>
    <p>保证一个类有且仅有一个实例，并且提供一个全局访问点</p>

    <ul>
      <li>
        <p>为什么要有全局访问点?：只要是在同一个域下调用，返回的都是同一个对象</p>
      </li>
      <li>
        <p><del>全局访问点的目的： 不变和共享</del></p>
        <ul>
          <li><del>不变：两个对象进行严格相等操作 ？</del></li>
          <li><del>共享：调用任意一个对象，返回的都是相同的指向</del></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>单例模式之所以这么叫，是因为它限制一个类只能有一个实例化对象。经典的实现方式是，创建一个类，这个类包含一个方法，这个方法在没有对象存在的情况下，将会创建一个新的实例对象。如果对象存在，这个方法只是返回这个对象的引用。</li>
  <li>饿汉式(空间换时间)；懒汉式(时间换空间)；静态内部类(时间换空间)；</li>
  <li>点开垃圾站操作=&gt;切换工作分区操作</li>
  <li>打开代码一惰性单例，演示</li>
  <li>总结:</li>
  <li>优点:1. 由于在系统内存中只存在一个对象，因此可以 节约系统资源，当 需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。</li>
  <li></li>
</ul>

<h3 id="ppt问题需求">–PPT问题需求</h3>

<ol>
  <li>单例模式的定义=&gt;保证一个类仅有一个<strong>实例</strong>，并提供一个访问它的全局访问点</li>
  <li>全局访问点的目的： 不变和共享；</li>
</ol>

<h3 id="-杂七杂八">-杂七杂八</h3>

<ul>
  <li>通用的单例创建的例子就是通过封装一个getSingle需要实现单例模式的对象。而且只是会只创建一次。因为使用了闭包的原因通过getSingle创建的result会在内存中一直存在不会销毁</li>
</ul>

<h3 id="react">–React</h3>

<ul>
  <li>event 对象的 target 属性中带有输入框的值</li>
  <li><code class="highlighter-rouge">**includes()**</code>方法确定数组是否在其条目中包括特定值，返回<code class="highlighter-rouge">true</code>或<code class="highlighter-rouge">false</code>；</li>
</ul>
:ET